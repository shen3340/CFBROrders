<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="Npgsql" #>
<#@ assembly name="C:\Users\shen3\.nuget\packages\system.componentmodel.annotations\5.0.0\lib\netstandard2.0\System.ComponentModel.Annotations.dll" #>
<#@ assembly name="System.Configuration" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data" #>
<#@ import namespace="Npgsql" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.ComponentModel.DataAnnotations.Schema" #>
<#@ import namespace="System.Configuration" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>

using NPoco;

<#
string configPath = Host.ResolvePath(@"..\App.config");

if (!File.Exists(configPath))
    throw new FileNotFoundException($"App.config not found at: {configPath}");

var fileMap = new ExeConfigurationFileMap { ExeConfigFilename = configPath };
var config = ConfigurationManager.OpenMappedExeConfiguration(fileMap, ConfigurationUserLevel.None);

if (config.ConnectionStrings == null)
    throw new Exception("No <connectionStrings> section found in App.config.");

var csElement = config.ConnectionStrings.ConnectionStrings["ConnectionString"];
if (csElement == null)
    throw new Exception("Connection string 'ConnectionString' not found in App.config.");

string connectionString = csElement.ConnectionString;

using var conn = new NpgsqlConnection(connectionString);
conn.Open();

var tables = new List<string>();
using (var cmd = new NpgsqlCommand(@"
    SELECT table_name 
    FROM information_schema.tables 
    WHERE table_schema='public' 
    AND table_type IN ('BASE TABLE', 'VIEW')
    ORDER BY table_name", conn))
{
    using (var reader = cmd.ExecuteReader())
    {
        while (reader.Read())
            tables.Add(reader.GetString(0));
    }
}
#>

<# 
// Header comment for generated file
WriteLine("// This file was automatically generated by the T4 Template");
WriteLine("// Do not make changes directly to this file - edit the template instead");
WriteLine("// ");
WriteLine("// The following connection settings were used to generate this file");
WriteLine("// ");
WriteLine("//     Connection String Name: `ConnectionString`"); 
WriteLine("//     Provider:               `Npgsql`");
WriteLine("//     Schema:                 `public`");
WriteLine("//     Include Views:          `true`");
WriteLine("//");
WriteLine("//     Last Generated:         `{0}`", DateTime.Now);
WriteLine("");
#>


namespace CFBROrders.SDK.Models
{
<#
foreach (var table in tables)
{
    var cols = new List<(string name, string type, bool nullable, bool autoIncrement)>();
    var pkCols = new HashSet<string>();

    // -------------------------
    // Load Columns
    // -------------------------
    using (var colCmd = new NpgsqlCommand($@"
        SELECT c.column_name, c.udt_name, c.is_nullable,
               (c.column_default LIKE 'nextval(%' OR c.is_identity = 'YES') as auto_inc
        FROM information_schema.columns c
        WHERE c.table_schema = 'public'
          AND c.table_name = '{table}'
        ORDER BY c.ordinal_position", conn))
    {
        using (var colReader = colCmd.ExecuteReader())
        {
            while (colReader.Read())
{
    string name = colReader.GetString(0);
    string type = MapPostgresType(colReader.GetString(1));
    bool nullable = colReader.GetString(2) == "YES";

    bool autoIncrement = false;
    if (!colReader.IsDBNull(3))
        autoIncrement = colReader.GetBoolean(3);

    cols.Add((name, type, nullable, autoIncrement));
}

        }
    }

    // -------------------------
    // Load Primary Keys
    // -------------------------
    using (var pkCmd = new NpgsqlCommand($@"
        SELECT kcu.column_name
        FROM information_schema.table_constraints tc
        JOIN information_schema.key_column_usage kcu
             ON tc.constraint_name = kcu.constraint_name
             AND tc.table_schema = kcu.table_schema
        WHERE tc.constraint_type = 'PRIMARY KEY'
          AND tc.table_schema = 'public'
          AND tc.table_name = '{table}'", conn))
    {
        using (var pkReader = pkCmd.ExecuteReader())
        {
            while (pkReader.Read())
            {
                pkCols.Add(pkReader.GetString(0));
            }
        }
    }
#>
    [NPoco.TableName("<#= table #>")]
<#  if (pkCols.Count > 0) { 
        bool singleAutoInc = pkCols.Count == 1 && cols.First(c => c.name == pkCols.First()).autoIncrement;
#>
    [NPoco.PrimaryKey("<#= string.Join(", ", pkCols) #>"<#= singleAutoInc ? ", AutoIncrement = true" : "" #>)]
<#  } #>
    public partial class <#= Singularize(PascalCase(table)) #>
    {
<#
    foreach (var c in cols)
    {
#>
        [Column("<#= c.name #>")]
        public <#= c.type #><#= (c.nullable && c.type != "string" ? "?" : "") #> <#= PascalCase(c.name) #> { get; set; }
<#
    } // end foreach cols
#>
    } 
<#
} // end foreach table
#>
}



<#+
string PascalCase(string input)
{
    if (string.IsNullOrEmpty(input)) return input;
    var parts = input.Split('_');
    var sb = new StringBuilder();
    foreach (var p in parts)
        sb.Append(char.ToUpper(p[0]) + p.Substring(1));
    return sb.ToString();
}

string Singularize(string name)
{
    if (string.IsNullOrEmpty(name)) return name;

    if (name.Equals("territories", StringComparison.OrdinalIgnoreCase))
        return "Territory";

    if (name.EndsWith("s") && name.Length > 1)
        return name.Substring(0, name.Length - 1);

    return name;
}

string SafePropertyName(string name)
{
    string[] keywords = new string[]
    {
        "abstract","as","base","bool","break","byte","case","catch","char","checked","class","const","continue",
        "decimal","default","delegate","do","double","else","enum","event","explicit","extern","false","finally",
        "fixed","float","for","foreach","goto","if","implicit","in","int","interface","internal","is","lock",
        "long","namespace","new","null","object","operator","out","override","params","private","protected",
        "public","readonly","ref","return","sbyte","sealed","short","sizeof","stackalloc","static","string",
        "struct","switch","this","throw","true","try","typeof","uint","ulong","unchecked","unsafe","ushort",
        "using","virtual","void","volatile","while"
    };
    return keywords.Contains(name) ? "@" + name : name;
}

string MapPostgresType(string pgType)
{
    if (pgType.StartsWith("_"))
    {
        switch (pgType)
        {
            case "_int4": return "int[]";
            case "_int8": return "long[]";
            case "_int2": return "short[]";
            case "_text": return "string[]";
            default: return "string[]";
        }
    }

    switch (pgType)
    {
        case "int4":
        case "integer": return "int";

        case "int8":
        case "bigint": return "long";

        case "int2":
        case "smallint": return "short";

        case "bool":
        case "boolean": return "bool";

        case "text":
        case "varchar":
        case "character varying":
        case "character": return "string";

        case "timestamp":
        case "timestamp without time zone":
        case "timestamp with time zone":
        case "date": return "DateTime";

        case "numeric": return "decimal";

        case "float8":
        case "double precision": return "double";

        case "float4":
        case "real": return "float";

        case "uuid": return "Guid";

        default: return "string";
    }
}

#>


